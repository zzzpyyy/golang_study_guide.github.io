<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/golang_study_guide.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/golang_study_guide.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/golang_study_guide.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/golang_study_guide.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/golang_study_guide.github.io/css/main.css">


<link rel="stylesheet" href="/golang_study_guide.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zzzpyyy.github.io","root":"/golang_study_guide.github.io/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false,"b2t":false,"scrollpercent":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Golang1. new和make的区别两个关键字都可以初始化 12345make：主要用于slice、map、channel的初始化new：根据传入的类型分配一片内存空间并返回指向这片内存空间的指针slice :&#x3D; make([]int, 0, 100)hash :&#x3D; make(map[int]bool, 10)ch :&#x3D; make(chan int, 5) slice 是一个包含 data、c">
<meta property="og:type" content="article">
<meta property="og:title" content="字节面试题">
<meta property="og:url" content="https://zzzpyyy.github.io/golang_study_guide.github.io/2024/06/08/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95/index.html">
<meta property="og:site_name" content="Golang Study Guide">
<meta property="og:description" content="Golang1. new和make的区别两个关键字都可以初始化 12345make：主要用于slice、map、channel的初始化new：根据传入的类型分配一片内存空间并返回指向这片内存空间的指针slice :&#x3D; make([]int, 0, 100)hash :&#x3D; make(map[int]bool, 10)ch :&#x3D; make(chan int, 5) slice 是一个包含 data、c">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-06-08T14:27:12.000Z">
<meta property="article:modified_time" content="2024-06-09T04:01:28.329Z">
<meta property="article:author" content="zpy">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zzzpyyy.github.io/golang_study_guide.github.io/2024/06/08/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>字节面试题 | Golang Study Guide</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/golang_study_guide.github.io/atom.xml" title="Golang Study Guide" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/golang_study_guide.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Golang Study Guide</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/golang_study_guide.github.io/" rel="section"><i class="home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/golang_study_guide.github.io/about/" rel="section"><i class="user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/golang_study_guide.github.io/tags/" rel="section"><i class="tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/golang_study_guide.github.io/categories/" rel="section"><i class="th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/golang_study_guide.github.io/archives/" rel="section"><i class="archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zzzpyyy.github.io/golang_study_guide.github.io/2024/06/08/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/golang_study_guide.github.io/images/avatar.gif">
      <meta itemprop="name" content="zpy">
      <meta itemprop="description" content="golang学习指南">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Golang Study Guide">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          字节面试题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-06-08 22:27:12" itemprop="dateCreated datePublished" datetime="2024-06-08T22:27:12+08:00">2024-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-06-09 12:01:28" itemprop="dateModified" datetime="2024-06-09T12:01:28+08:00">2024-06-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h1><h2 id="1-new和make的区别"><a href="#1-new和make的区别" class="headerlink" title="1. new和make的区别"></a>1. new和make的区别</h2><p>两个关键字都可以初始化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>：主要用于slice、<span class="keyword">map</span>、channel的初始化</span><br><span class="line"><span class="built_in">new</span>：根据传入的类型分配一片内存空间并返回指向这片内存空间的指针</span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>, <span class="number">10</span>)</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>slice 是一个包含 data、cap 和 len 的结构体 reflect.SliceHeader；<br>hash 是一个指向 runtime.hmap 结构体的指针；<br>ch 是一个指向 runtime.hchan 结构体的指针</p>
<h2 id="2-函数传值和传指针的区别"><a href="#2-函数传值和传指针的区别" class="headerlink" title="2. 函数传值和传指针的区别"></a>2. 函数传值和传指针的区别</h2><p>传值： 将参数值复制一份传递给函数，函数内部对参数修改不会影响到原来的变量<br>传指针： 将参数的地址传递给函数，函数内部对参数修改会影响到原来的变量<br>区别： 性能可以提升，大型数据结构避免复制，数据拷贝，减少了内存使用，提高性能，但是会修改原有banal，在某些情况下安全性较低，可能会导致意外的副作用</p>
<h2 id="3-数组和切片的区别"><a href="#3-数组和切片的区别" class="headerlink" title="3. 数组和切片的区别"></a>3. 数组和切片的区别</h2><p>数组的长度时固定的，切片是可变的、数组是值类型、而切片是引用类型<br>切片是对数组的封装、包含了指向数组的指针以及长度容量信息</p>
<h2 id="4-什么是内存逃逸、在什么情况下发生、原理是什么"><a href="#4-什么是内存逃逸、在什么情况下发生、原理是什么" class="headerlink" title="4. 什么是内存逃逸、在什么情况下发生、原理是什么"></a>4. 什么是内存逃逸、在什么情况下发生、原理是什么</h2><p>内存逃逸：简单来说就是一个变量原本应该分配在栈上，但是由于生命周期超出函数的范围需要分配在堆上，go编译器在编译过中进行逃逸分析以确定变量应该分配在哪里<br>什么情况下发生：<br>返回指针：函数返回局部变量的指针</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createPointer</span><span class="params">()</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> &amp;a</span><br><span class="line">&#125;</span><br><span class="line">闭包捕获变量：闭包（匿名函数）捕获了外部变量</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createClosure</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">接口类型转换：当变量转换为接口类型时，由于接口可能在函数外使用，会逃逸到堆上</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">interfaceEscape</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">动态数据结构：切片 、<span class="keyword">map</span>、channel，可能会逃逸到堆上</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceEscape</span><span class="params">()</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理： go编译器在编译的过程中，会对每个变量进行逃逸分析，来确定变量应该分配到栈上还是堆上，主要包括分析变量的生命周期，以及是否存在指针或者引用的情况，闭包捕获的情况<br>可以使用go build -gcflags&#x3D;”-m”来进行分析</p>
<h2 id="5-逃逸分析，写一个"><a href="#5-逃逸分析，写一个" class="headerlink" title="5. 逃逸分析，写一个"></a>5. 逃逸分析，写一个</h2><p>go build -gcflags&#x3D;-m xxx.go </p>
<h2 id="6-Golang-GC-好与不好的点"><a href="#6-Golang-GC-好与不好的点" class="headerlink" title="6. Golang GC  好与不好的点"></a>6. Golang GC  好与不好的点</h2><p>最常见的垃圾回收算法有标记清除(Mark-Sweep) 和引用计数(Reference Count)，Go 语言采用的是标记清除算法。并在此基础上使用了三色标记法和写屏障技术，提高了效率。<br>标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：</p>
<ul>
<li>标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；</li>
<li>清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。<br>标记清除算法的一大问题是在标记期间，需要暂停程序（Stop the world，STW），标记结束之后，用户程序才可以继续执行。为了能够异步执行，减少 STW 的时间，Go 语言采用了三色标记法。<br>三色标记算法将程序中的对象分成白色、黑色和灰色三类。</li>
<li>白色：不确定对象。</li>
<li>灰色：存活对象，子对象待处理。</li>
<li>黑色：存活对象。<br>标记开始时，所有对象加入白色集合（这一步需 STW ）。首先将根对象标记为灰色，加入灰色集合，垃圾搜集器取出一个灰色对象，将其标记为黑色，并将其指向的对象标记为灰色，加入灰色集合。重复这个过程，直到灰色集合为空为止，标记阶段结束。那么白色对象即可需要清理的对象，而黑色对象均为根可达的对象，不能被清理。<br>三色标记法因为多了一个白色的状态来存放不确定对象，所以后续的标记阶段可以并发地执行。当然并发执行的代价是可能会造成一些遗漏，因为那些早先被标记为黑色的对象可能目前已经是不可达的了。所以三色标记法是一个 false negative（假阴性）的算法。<br>三色标记法并发执行仍存在一个问题，即在 GC 过程中，对象指针发生了改变。比如下面的例子：<br>正常情况下，D 对象最终会被标记为黑色，不应被回收。但在标记和用户程序并发执行过程中，用户程序删除了 C 对 D 的引用，而 A 获得了 D 的引用。标记继续进行，D 就没有机会被标记为黑色了（A 已经处理过，这一轮不会再被处理）。<br>为了解决这个问题，Go 使用了内存屏障技术，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，类似于一个钩子。垃圾收集器使用了写屏障（Write Barrier）技术，当对象新增或更新时，会将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。<br>一次完整的 GC 分为四个阶段：</li>
<li>1）标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)</li>
<li>2）使用三色标记法标记（Marking, 并发）</li>
<li>3）标记结束(Mark Termination，需 STW)，关闭写屏障。</li>
<li>4）清理(Sweeping, 并发)</li>
<li>参考 fullstack<br>好与不好的点<br>好： 自动内存管理、并发标记清楚（减少了STW（stop the world）的时间）、增量回收、高并发、三色标记 高效<br>不好：非实时性（在某些情况（高负载大内存），延迟不确定，可能会出现较长的延迟）、有一定的额外开销、内存使用较大（逃逸分析）</li>
</ul>
<h2 id="7-Golang-GC-stw-（stop-the-world）"><a href="#7-Golang-GC-stw-（stop-the-world）" class="headerlink" title="7. Golang GC stw （stop-the-world）"></a>7. Golang GC stw （stop-the-world）</h2><p>STW（Stop-The-World）是指在某些阶段，垃圾回收器需要暂停应用程序的所有goroutine来完成一些关键操作。虽然Go的垃圾回收器设计旨在尽量减少STW的时间，但STW仍然是影响应用程序响应性能的一个重要因素<br>STW主要发生在以下阶段：</p>
<ol>
<li>初始标记阶段：</li>
</ol>
<ul>
<li>标记所有根对象（例如全局变量和goroutine栈顶的变量）为灰色，这些对象将成为GC扫描的起点。</li>
<li>需要短暂的STW来确保在标记开始时应用程序的状态是一致的。</li>
</ul>
<ol start="2">
<li>终止标记阶段：</li>
</ol>
<ul>
<li>确保所有存活对象都已被正确标记为黑色。</li>
<li>在并发标记结束后，再次进行短暂的STW来处理标记过程中可能遗漏的对象。<br>STW的影响</li>
</ul>
<ol>
<li>暂停时间：</li>
</ol>
<ul>
<li>STW的暂停时间会直接影响应用程序的响应速度和性能，特别是在低延迟、高实时性要求的应用中，这种暂停可能是不可接受的。</li>
<li>Go的设计目标是尽量缩短STW的时间，通过并发和增量的回收策略来减少STW的影响。</li>
</ul>
<ol start="2">
<li>延迟和抖动：</li>
</ol>
<ul>
<li>虽然STW时间通常很短，但频繁的STW可能导致应用程序的延迟和抖动，影响用户体验。</li>
<li>高负载下，STW时间可能会增加，进一步影响应用的性能。<br>具体实现和优化<br>开始STW：</li>
<li>时机：在开始标记阶段之前，需要进行一次短暂的STW。这个STW的目的是确保所有的P（处理器）都停止在安全点，即一个不会修改堆的位置。</li>
<li>解决方法：这个STW时间通常非常短，它确保在标记阶段开始时，所有的goroutine都不会创建新的对象或修改现有对象的指针。<br>结束STW：</li>
<li>时机：在标记阶段结束后，需要进行一次短暂的STW。这个STW的目的是确保所有的goroutine都停止在安全点，然后进行最后一次的标记，并开始清除阶段。</li>
<li>解决方法：这个STW的时间也通常非常短，它确保在清除阶段开始时，所有的对象都已经被正确地标记。<br>并发标记：</li>
<li>解决方法：在标记阶段，Go的GC采用了并发标记的策略。通过写屏障（Write Barrier）技术，每次写入指针时都会标记该指针。这样，即使在标记阶段有新的对象被分配或旧的对象被更新，GC也能正确地标记这些对象。<br>并发清除：</li>
<li>解决方法：在清除阶段，Go的GC采用了并发清除的策略。通过延迟清除（Lazy Sweeping）技术，即只在需要分配新的对象时才清除那个对象所在的内存块。<br>Go的垃圾回收器使用了许多技术来优化STW的时间：</li>
</ul>
<ol>
<li>并发标记和清除：</li>
</ol>
<ul>
<li>在标记阶段，大部分工作是并发进行的，只有在初始标记和终止标记阶段需要STW。</li>
<li>清除阶段也是并发进行的，减少了需要STW的时间。</li>
</ul>
<ol start="2">
<li>增量回收：</li>
</ol>
<ul>
<li>增量标记使得标记过程可以分阶段进行，每个阶段都只需要短暂的STW，从而平滑GC的影响。</li>
</ul>
<ol start="3">
<li>调优参数：</li>
</ol>
<ul>
<li>可以通过调整GOGC参数来控制GC的频率，从而间接影响STW的时间和频率。</li>
<li>GODEBUG环境变量提供了一些调试和调优选项，可以用于监控和分析STW时间。<br>监控STW时间<br>使用Go提供的工具可以监控和分析GC的STW时间：</li>
</ul>
<ol>
<li>GODEBUG&#x3D;gctrace&#x3D;1：</li>
</ol>
<ul>
<li>启用GC跟踪信息，可以在标准输出中看到每次GC的详细信息，包括STW时间。<br>pprof工具：</li>
<li>Go内置的性能分析工具pprof可以用于分析GC的性能，查看STW时间。</li>
</ul>
<h2 id="8-Channel-原理"><a href="#8-Channel-原理" class="headerlink" title="8. Channel 原理"></a>8. Channel 原理</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="type">uint</span>           <span class="comment">// 队列中已存数据的数量</span></span><br><span class="line">    dataqsiz <span class="type">uint</span>           <span class="comment">// 环形队列的大小</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 环形队列指针</span></span><br><span class="line">    elemsize <span class="type">uint16</span>         <span class="comment">// 元素大小</span></span><br><span class="line">    closed   <span class="type">uint32</span>         <span class="comment">// 标记通道是否已关闭</span></span><br><span class="line">    elemtype *_type         <span class="comment">// 元素类型</span></span><br><span class="line">    sendx    <span class="type">uint</span>           <span class="comment">// 下一个发送位置的索引</span></span><br><span class="line">    recvx    <span class="type">uint</span>           <span class="comment">// 下一个接收位置的索引</span></span><br><span class="line">    recvq    waitq          <span class="comment">// 等待接收的 goroutine 队列</span></span><br><span class="line">    sendq    waitq          <span class="comment">// 等待发送的 goroutine 队列</span></span><br><span class="line">    lock     mutex          <span class="comment">// 互斥锁，保护 hchan 的并发访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">    first *sudog</span><br><span class="line">    last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>channel主要用在goroutine之间进行通信和同步，底层实现相当复杂，它的核心数据结构是hchan结构体，定义在runtime包里，hchan结构体主要包含环形队列、等待队列，锁、以及消息相关的一些字段。环形队列部分里面有一个buf指针指向内存区域，用于存储实际的数据。datasize则是环形队列的大小，sendx、recvx则是下一个发送接收的位置索引。当发送数据时，如果环形队列未满，则会把数据复制到sendx上，并更新sendx，环形队列满了就阻塞放入等待队列sendq中等待。接收数据时，如果有数据就会拉取到recvx上，同时更新recvx。没有数据则阻塞放入recvq队列中等待。为了保证并发访问，通过lock互斥锁来确保操作是安全的，channel关闭的时候会对其进行标记，以及唤醒等待队列中的goroutine，进行处理。总的来说，channel通过hchan结构体实现，通过环形队列、等待队列、和互斥锁来并发管理数据传输同步。保证了goroutine之间安全高效的传递数据。<br>channel是goroutine之间通信的管道，可以用来传递数据，发送方通过 ch &lt;-  操作符发送数据到通道，接收方通过&lt;- ch  操作符从通道接收数据</p>
<p>无缓冲的channel， 发送方将阻塞该信道，直到接收方从该信道接收完数据为止，而接收方也将阻塞该信道，直到发送方将数据发送道该信道中为止<br>有缓冲道channel，发送方在缓冲区未满的时候不会阻塞，如果缓冲区满了，则阻塞，接收方则会在信道为空的时候阻塞</p>
<h2 id="9-GMP模型"><a href="#9-GMP模型" class="headerlink" title="9. GMP模型"></a>9. GMP模型</h2><p>GMP 模型是 Go 语言运行时系统（runtime system）中的一种并发调度模型，用于管理 Goroutine 和操作系统线程之间的关系。GMP 模型中的主要组件包括 Goroutine、M（Machine）和 P（Processor）。</p>
<ol>
<li>Goroutine：Goroutine 是 Go 语言中轻量级的并发执行单元，类似于线程，但是比线程更加轻量级和高效。Goroutine 是由 Go 运行时系统调度执行的，并且可以通过 go 关键字创建。</li>
<li>M（Machine）：M 是操作系统线程的抽象，负责执行 Goroutine。M 被 Go 运行时系统管理，可以创建和销毁，也可以被重新利用。</li>
<li>P（Processor）：P 是 Goroutine 和 M 之间的连接，负责调度 Goroutine 到 M 上执行。P 与操作系统线程是一对一的关系，一个 P 对应一个 M。<br>在 GMP 模型中，P 负责调度 Goroutine 到 M 上执行，而 M 负责执行 Goroutine。为了避免全局队列饥饿的问题，Go 运行时系统实现了以下几种策略：</li>
</ol>
<ul>
<li>抢占式调度：Go 运行时系统采用抢占式调度策略，当一个 Goroutine 执行时间过长时，会被强制挂起，并重新调度其他 Goroutine。这样可以避免某个 Goroutine 占用太多的 CPU 时间，导致其他 Goroutine 无法执行。</li>
<li>局部队列和全局队列：Go 运行时系统中有两种类型的队列：局部队列和全局队列。每个 P 都有自己的局部队列，用于存储待执行的 Goroutine。当一个 P 的局部队列为空时，它会从全局队列中获取 Goroutine 来执行，这样可以避免某个 P 的局部队列耗尽，导致该 P 无法执行任何 Goroutine。</li>
<li>工作窃取（Work Stealing）：当一个 P 的局部队列为空，但是其他 P 的局部队列中有待执行的 Goroutine 时，该 P 可以从其他 P 的局部队列中窃取 Goroutine 来执行。这样可以实现 Goroutine 的负载均衡，避免某个 P 长时间空闲。<br>通过以上策略，Go 运行时系统可以有效地避免全局队列饥饿问题，实现了高效的 Goroutine 调度和执行。</li>
</ul>
<h2 id="10-context包了解吗"><a href="#10-context包了解吗" class="headerlink" title="10. context包了解吗"></a>10. context包了解吗</h2><p>context ：上下文，主要用来在 goroutine 之间传递上下文信息，包括：取消信号、超时时间、截止时间、k-v 等。主要用于管理goroutine的生命周期，可以处理并发时候的取消、超时和传递上下文的消息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取消</span></span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Do some work</span></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    cancel()  <span class="comment">// Cancel the context</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">    fmt.Println(<span class="string">&quot;Operation cancelled&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">5</span> * time.Second):</span><br><span class="line">    fmt.Println(<span class="string">&quot;Operation completed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//超时</span></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">2</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">    fmt.Println(<span class="string">&quot;Operation timed out:&quot;</span>, ctx.Err())</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):</span><br><span class="line">    fmt.Println(<span class="string">&quot;Operation completed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传递数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx := context.WithValue(context.Background(), <span class="string">&quot;requestID&quot;</span>, <span class="string">&quot;12345&quot;</span>)</span><br><span class="line">    handleRequest(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleRequest</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    reqID := ctx.Value(<span class="string">&quot;requestID&quot;</span>).(<span class="type">string</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Handling request with ID:&quot;</span>, reqID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协同</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> worker(ctx, i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    cancel()  <span class="comment">// Cancel all workers</span></span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)  <span class="comment">// Give workers time to clean up</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ctx context.Context, id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;Worker&quot;</span>, id, <span class="string">&quot;cancelled&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;Worker&quot;</span>, id, <span class="string">&quot;working&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-map原理，为什么是无序的"><a href="#11-map原理，为什么是无序的" class="headerlink" title="11. map原理，为什么是无序的"></a>11. map原理，为什么是无序的</h2><p>go语言中，map通过哈希函数将key分配到不同的桶中，其主要的开销在哈希函数的计算和数组的常数访问时间，因此哈希表的查找性能很高。由于是哈希函数分配可能存在哈希冲突，主要使用链地址法或开放地址法来解决哈希冲突<br>map为什么是无序的：由于map会动态扩容，会复制key到扩容之后的的桶中在扩容之后，原本落在同一个桶里的key会发生变化，因此是无序的<br>key取值：理论上除去map、slice、function都可以作为key<br>map是线程不安全的，理论上可以边删边读，但是可能存在读取数据不一致的问题<br>sync.Map 是线程安全的 map，也可以使用</p>
<h2 id="12-协程的优势"><a href="#12-协程的优势" class="headerlink" title="12. 协程的优势"></a>12. 协程的优势</h2><p>轻量：只占用很少的内存（2kb）、高并发、简单、上下文切换只在用户态中进行，更加高效，自带调度器自动管理、自动垃圾回收</p>
<h2 id="13-进程、线程、协程"><a href="#13-进程、线程、协程" class="headerlink" title="13. 进程、线程、协程"></a>13. 进程、线程、协程</h2><p>线程和协程区别，要从栈的大小、调度、切换这三个角度来讲。<br>进程可以理解为一个动态的程序，进程是操作系统资源分配的基本单位，而线程是操作系统调度的基本单位，进程独占一个虚拟内存空间，而进程里的线程共享一个进程虚拟内存空间。线程的粒度更小<br>协程可以理解为用户态线程，跟线程的区别主要有三个方面<br>大小，协程到校为2k，可以动态扩容，而线程大小为2m,协程更轻量<br>线程切换需要用户态到内核态的切换，而协程的切换不用，只在用户态完成，切换消耗更小<br>线程的调度由操作系统完成，而协程的调度由运行时的调度器完成</p>
<h2 id="14-内存泄漏，为什么，怎么排查"><a href="#14-内存泄漏，为什么，怎么排查" class="headerlink" title="14. 内存泄漏，为什么，怎么排查"></a>14. 内存泄漏，为什么，怎么排查</h2><p>内存泄漏主要是因为分配的内存无法回收，长时间占用，导致内存占用不断增长，可能会导致耗尽系统资源<br>主要的原因：<br>全局变量持有引用：全局变量持有短生命周期对象的引用，导致短周期的对象无法回收<br>未关闭的通道：通道未正确关闭，导致阻塞或者不必要的引用<br>Goroutine泄漏：goroutine未正常退出，导致持有大量资源<br>缓存与集合未及时清理<br>闭包中的变量引用<br>如何排查：<br>可以使用pprof工具或者runtime包查看内存情况</p>
<h2 id="15-如何分配内存"><a href="#15-如何分配内存" class="headerlink" title="15. 如何分配内存"></a>15. 如何分配内存</h2><p>golang运行时的内存分配主要源于tcmalloc算法，将内存分为多级管理，从而降低锁的力度。在程序启动的时候会申请一大块内存，自行管理，go内存管理的基本单位是mspan，有若干页组成，每个mspan可以分配特定大小的object。通过，mcache管理线程在本地缓存的mspan， mcentral管理全局的mspan供所有线程用，mheap管理所有的动态内存分配。根据对象大小进行分配，极小对象分配到object中，一般小对象通过mspan分配，而大对象则有mheap分配</p>
<h2 id="16-channel分配在堆上还栈上"><a href="#16-channel分配在堆上还栈上" class="headerlink" title="16. channel分配在堆上还栈上"></a>16. channel分配在堆上还栈上</h2><p>go语言编译器会自动决定把对象分配在堆上或者栈上，如果变量作用范围在函数的生命周期内则分配在栈上，否则分配到堆上<br>Channel通常是分配到堆上的，由于channel是在多个goroutine之间使用的，需要跨函数使用，以及goroutine运行在不同的栈上，而需要channel通信，channel更适合在堆上，具体放在哪可以使用逃逸分析查看</p>
<h2 id="17-为什么小对象多了会造成gc压力"><a href="#17-为什么小对象多了会造成gc压力" class="headerlink" title="17. 为什么小对象多了会造成gc压力"></a>17. 为什么小对象多了会造成gc压力</h2><p>因为go中gc是标记清除算法，无论大小对象都会被管理，如果是大量小对象会增加标记清除是的开销，都是标记阶段遍历对象的时候会增加cpu负担，由于小对象生命周期较短也会频繁触发gc导致gc频繁运行，会引起stw影响系统性能。由于小对象还更容易导致内存碎片化</p>
<h2 id="18-Go-func与method之前的那个Receiver是什么？"><a href="#18-Go-func与method之前的那个Receiver是什么？" class="headerlink" title="18. Go func与method之前的那个Receiver是什么？"></a>18. Go func与method之前的那个Receiver是什么？</h2><p>go中函数和方法的区别在于有没有与某种类型相关联，函数通过使用receiver（接收器）与一个知道方法作用的对象相关联，可以是任意类型，通过接收器传递给方法，方法可以通过接收器访问操作对象的数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个类型</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rectangle类型的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span></span> Area() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建Rectangle对象</span></span><br><span class="line">    rect := Rectangle&#123;width: <span class="number">10</span>, height: <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用方法</span></span><br><span class="line">    area := rect.Area()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area:&quot;</span>, area)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="19-Go的闭包语法"><a href="#19-Go的闭包语法" class="headerlink" title="19.  Go的闭包语法"></a>19.  Go的闭包语法</h2><p>通过匿名函数实现的，不需要函数名，直接定义使用就可以，闭包就是一个函数值，引用了函数体之外的变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个外部变量</span></span><br><span class="line">    x := <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义一个闭包，引用外部变量x</span></span><br><span class="line">    add := <span class="function"><span class="keyword">func</span><span class="params">(y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用闭包</span></span><br><span class="line">    result := add(<span class="number">5</span>)</span><br><span class="line">    fmt.Println(result) <span class="comment">// 输出：15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    
        

  <div class="followme">
    <p>Welcome to my other publishing channels</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/golang_study_guide.github.io/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/golang_study_guide.github.io/2024/06/08/test/" rel="prev" title="test">
      <i class="fa fa-chevron-left"></i> test
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Golang"><span class="nav-number">1.</span> <span class="nav-text">Golang</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-new%E5%92%8Cmake%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.</span> <span class="nav-text">1. new和make的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%87%BD%E6%95%B0%E4%BC%A0%E5%80%BC%E5%92%8C%E4%BC%A0%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.</span> <span class="nav-text">2. 函数传值和传指针的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.</span> <span class="nav-text">3. 数组和切片的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E3%80%81%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%8F%91%E7%94%9F%E3%80%81%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.4.</span> <span class="nav-text">4. 什么是内存逃逸、在什么情况下发生、原理是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%EF%BC%8C%E5%86%99%E4%B8%80%E4%B8%AA"><span class="nav-number">1.5.</span> <span class="nav-text">5. 逃逸分析，写一个</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Golang-GC-%E5%A5%BD%E4%B8%8E%E4%B8%8D%E5%A5%BD%E7%9A%84%E7%82%B9"><span class="nav-number">1.6.</span> <span class="nav-text">6. Golang GC  好与不好的点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-Golang-GC-stw-%EF%BC%88stop-the-world%EF%BC%89"><span class="nav-number">1.7.</span> <span class="nav-text">7. Golang GC stw （stop-the-world）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-Channel-%E5%8E%9F%E7%90%86"><span class="nav-number">1.8.</span> <span class="nav-text">8. Channel 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-GMP%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.9.</span> <span class="nav-text">9. GMP模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-context%E5%8C%85%E4%BA%86%E8%A7%A3%E5%90%97"><span class="nav-number">1.10.</span> <span class="nav-text">10. context包了解吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-map%E5%8E%9F%E7%90%86%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A0%E5%BA%8F%E7%9A%84"><span class="nav-number">1.11.</span> <span class="nav-text">11. map原理，为什么是无序的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">1.12.</span> <span class="nav-text">12. 协程的优势</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B"><span class="nav-number">1.13.</span> <span class="nav-text">13. 进程、线程、协程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%8C%E6%80%8E%E4%B9%88%E6%8E%92%E6%9F%A5"><span class="nav-number">1.14.</span> <span class="nav-text">14. 内存泄漏，为什么，怎么排查</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="nav-number">1.15.</span> <span class="nav-text">15. 如何分配内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-channel%E5%88%86%E9%85%8D%E5%9C%A8%E5%A0%86%E4%B8%8A%E8%BF%98%E6%A0%88%E4%B8%8A"><span class="nav-number">1.16.</span> <span class="nav-text">16. channel分配在堆上还栈上</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%8F%E5%AF%B9%E8%B1%A1%E5%A4%9A%E4%BA%86%E4%BC%9A%E9%80%A0%E6%88%90gc%E5%8E%8B%E5%8A%9B"><span class="nav-number">1.17.</span> <span class="nav-text">17. 为什么小对象多了会造成gc压力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-Go-func%E4%B8%8Emethod%E4%B9%8B%E5%89%8D%E7%9A%84%E9%82%A3%E4%B8%AAReceiver%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.18.</span> <span class="nav-text">18. Go func与method之前的那个Receiver是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-Go%E7%9A%84%E9%97%AD%E5%8C%85%E8%AF%AD%E6%B3%95"><span class="nav-number">1.19.</span> <span class="nav-text">19.  Go的闭包语法</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zpy</p>
  <div class="site-description" itemprop="description">golang学习指南</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/golang_study_guide.github.io/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zpy</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/golang_study_guide.github.io/lib/anime.min.js"></script>
  <script src="/golang_study_guide.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/golang_study_guide.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/golang_study_guide.github.io/js/utils.js"></script>

<script src="/golang_study_guide.github.io/js/motion.js"></script>


<script src="/golang_study_guide.github.io/js/schemes/pisces.js"></script>


<script src="/golang_study_guide.github.io/js/next-boot.js"></script>




  




  
<script src="/golang_study_guide.github.io/js/local-search.js"></script>













  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'Ov23lifJRJGv085ZRnJ1',
      clientSecret: 'd51ab5c2a704c50e001c80a595c2228d128ce16a',
      repo        : 'golang_study_guide.github.io',
      owner       : 'zzzpyyy',
      admin       : ['zzzpyyy'],
      id          : '65fdd8430868db02d9ae9dbf20f141fd',
        language: '',
      distractionFreeMode: false
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
